<!doctype html>
<meta charset="utf-8">

<html>

<head>
	<title>Assignment 3</title>
	<script src="http://d3js.org/d3.v3.min.js"> </script>
</head>

<style>
.axis path,
.axis line {
  fill: none;
  stroke: #000;
  shape-rendering: crispEdges;
}

.timeseries_daily_line {
  fill: none;
  stroke: steelblue;
  stroke-width: 1.5px;
}
</style>

<body>
	
	<script>
    // Helpers
    // Shamelessly lifted from https://stackoverflow.com/questions/15313418/javascript-assert
    function assert(condition, message) {
        if (!condition) {
            console.log("Assertion failed: " + (message || ""));
        }
    }   
    
    // Shamelessly lifted from https://stackoverflow.com/questions/1408289/best-way-to-do-variable-interpolation-in-javascript
    String.prototype.supplant = function (o) {
        return this.replace(/{([^{}]*)}/g,
            function (a, b) {
                var r = o[b];
                return typeof r === 'string' || typeof r === 'number' ? r : a;
            }
        );
    };
    
    // Actual code
	var rezised_body = d3.selectAll("body")
							.style("height", 100 + "%"); //just to force the browser to recognize the height of the screen

    // Data specific variables ("the schema")
    var components = ["Cooling", "Heating", "Lighting", "Plug Loads"]
                            
	//LAYOUT VARIABLES///
	var line_graph_width = 60; //I'm working with screen percentages. In this way we can resize the browser window and every thing will update.
	var line_graph_height = 95; //However if we figure that this is becoming a little bit difficult to manage we will resort to pixels
	var bar_graph_width = 100 - line_graph_width; //That is why I abstract it into variables

	//SVG Canvas for each graph///
	var line_graph_canvas = rezised_body.append("svg")
								.attr("width", line_graph_width + "%")
								.attr("height", line_graph_height + "%")
								.style("float", "left"); // the trick to make them side by side

	var rect = line_graph_canvas.append("rect") //NOTE: This is Aux Code - just to test the canvas for the line graph is ok
								.attr("width", 100 + "%")
								.attr("height", 100 + "%")
								.attr("fill", "grey");

	var bar_graph_canvas = rezised_body.append("svg")
								.attr("width", bar_graph_width + "%")
								.attr("height", line_graph_height + "%"); // in order to be the same

	var rect = bar_graph_canvas.append("rect") //NOTE: This is Aux Code - just to test if the canvas for the bar graph is ok
								.attr("width", 100 + "%")
								.attr("height", 100 + "%")
								.attr("fill", "blue")
								.style("float", "left");

    // Load datasets
    // Returns an object of {min: ..., max:..., avg:...} parsed from the row.
    function parse_component(row_record, component_name) {
        var obj =  {
            min: +row_record[component_name + " Daily Minimum"],
            max: +row_record[component_name + " Daily Maximum"],
            avg: +row_record[component_name + " Average "],
        }
        assert(!isNaN(obj.min), "Parse {comp} min failed: {row}".supplant({comp: component_name, row: row_record}))
        assert(!isNaN(obj.max), "Parse {comp} max failed: {row}".supplant({comp: component_name, row: row_record}))
        assert(!isNaN(obj.avg), "Parse {comp} avg failed: {row}".supplant({comp: component_name, row: row_record}))
        return obj
    }
    
    // Called once the daily timeseries CSV has been loaded.
    function on_daily_data(error, rows) {
        console.log(rows)
        // TODO: timeseries rendering
        
        // TODO: piechart / barchart aggregation and rendering

    }
    
    d3.dsv(";", "text/plain")("data_set.csv")
        .row(function(d) { 
            var obj = {"total":{min:0.0, max:0.0, avg:0.0}}
            components.forEach(function (component) {
                obj[component] = parse_component(d, component)
                obj.total.min += obj[component].min
                obj.total.max += obj[component].max
                obj.total.avg += obj[component].avg
            })
            
            return obj
        }).get(on_daily_data);
                  
	</script>

</body>

</html>